package com.sandy.jovenotes.processor.async;

import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.Calendar;

import org.apache.log4j.Logger;

import com.sandy.jovenotes.processor.JoveNotes;
import com.sandy.jovenotes.processor.dao.AbstractDBO;
import com.sun.xml.internal.messaging.saaj.util.ByteInputStream;
import com.sun.xml.internal.messaging.saaj.util.ByteOutputStream;

public class PersistentQueue extends AbstractDBO {
	
	private static Logger log = Logger.getLogger( PersistentQueue.class ) ;
	
	public static class QueueElement {
		
		private int          id                = 0 ;
		private String       uid               = null ;
		private Timestamp    creationTime      = null ;
		private PersistedCmd object            = null ;
		private int          numTimesProcessed = 0 ;
		private Timestamp    lastProcessTime   = null ;
		
		private QueueElement( ResultSet rs ) throws Exception {
			
			id = rs.getInt( 1 ) ;
			uid = rs.getString( 2 ) ;
			creationTime = rs.getTimestamp( 3 ) ;
			
			InputStream is = rs.getBlob( 4 ).getBinaryStream() ;
			ObjectInputStream ois = new ObjectInputStream( is ) ;
			object = ( PersistedCmd )ois.readObject() ;
			
			numTimesProcessed = rs.getInt( 5 ) ;
			lastProcessTime = rs.getTimestamp( 6 ) ;
		}
		
		private QueueElement( PersistedCmd obj ) {
			this.creationTime = new Timestamp( Calendar.getInstance().getTimeInMillis() ) ;
			this.object = obj ;
			this.uid    = obj.getUID() ;
		}
		
		public Object getObject() {
			return this.object ;
		}
		
		private void delete() throws Exception {
			
			String sql = "delete from jove_notes.persistent_queue where id = ?" ; 
			Connection conn = JoveNotes.db.getConnection() ;
			try {
				logQuery( "QueueElement::delete", sql ) ;
				PreparedStatement psmt = conn.prepareStatement( sql ) ;
				psmt.setInt( 1, id ) ;
				psmt.execute() ;
			}
			finally {
				JoveNotes.db.returnConnection( conn ) ;
			}
		}
		
		private boolean exists() throws Exception {
			
			String sql = "select 1 from jove_notes.persistent_queue where uid = ?" ; 
			
			boolean exists = false ;
			Connection conn = JoveNotes.db.getConnection() ;
			
			try {
				logQuery( "QueueElement::exists", sql ) ;
				PreparedStatement psmt = conn.prepareStatement( sql ) ;
				psmt.setString( 1, uid ) ;
				ResultSet rs = psmt.executeQuery() ;
				if( rs.next() ) {
					exists = true ;
				}
			}
			finally {
				JoveNotes.db.returnConnection( conn ) ;
			}
			return exists ;
		}
		
		private void create() throws Exception {
			
			if( exists() ) {
				log.debug( "\t  Cmd already exists in queue. Not creating another." ) ;
				return ;
			}
			
			String sql = 
				"insert into jove_notes.persistent_queue " + 
				"	( uid, creation_time, serialized_obj, num_times_processed, last_process_time ) " +
				"values ( ?, ?, ?, ?, ? )" ;

			ByteInputStream    bis = null ;
			ByteOutputStream   bos = null ;
			ObjectOutputStream oos = null ;
			
			Connection conn = JoveNotes.db.getConnection() ;
			PreparedStatement psmt = null ;
			
			try {
				logQuery( "QueueElement::create", sql ) ;
				
				psmt = conn.prepareStatement( sql, Statement.RETURN_GENERATED_KEYS ) ;
				psmt.setString( 1, uid ) ;
				psmt.setTimestamp( 2, creationTime ) ;
				
				bos = new ByteOutputStream() ;
				oos = new ObjectOutputStream( bos ) ;
				oos.writeObject( object ) ;
				oos.close() ;
				bis = new ByteInputStream( bos.getBytes(), bos.getCount() ) ;
				
				psmt.setBinaryStream( 3, bis ) ;
				psmt.setInt( 4, numTimesProcessed ) ;
				psmt.setTimestamp( 5, lastProcessTime ) ;
				
				psmt.executeUpdate() ;
				ResultSet rs = psmt.getGeneratedKeys() ;
				if( null != rs && rs.next()) {
				     id = (int)rs.getLong( 1 ) ;
				}
				else {
					throw new Exception( "Autogenerated key not obtained for " + 
				                         "queue element." ) ;
				}
			}
			finally {
				JoveNotes.db.returnConnection( conn ) ;
			}
		}
		
		public void reCreate() throws Exception {
			this.numTimesProcessed += 1 ;
			this.lastProcessTime = new Timestamp( Calendar.getInstance().getTimeInMillis() ) ;
			create() ;
		}
	}

	public void add( PersistedCmd obj ) throws Exception {
		QueueElement element = new QueueElement( obj ) ;
		element.create() ;
	}
	
	public QueueElement remove() throws Exception {
		
		final String selectSQL = 
		"SELECT " + 
				"id, uid, creation_time, serialized_obj, num_times_processed, last_process_time " + 
		"FROM jove_notes.persistent_queue " +
		"ORDER BY id asc LIMIT 1" ; 
		
		QueueElement element = null ;
		
		Connection conn = JoveNotes.db.getConnection() ;
		try {
			logQuery( "PersistentQueue::remove", selectSQL ) ;
			PreparedStatement psmt = conn.prepareStatement( selectSQL ) ;
			ResultSet rs = psmt.executeQuery() ;
			if( rs.next() ) {
				element = new QueueElement( rs ) ;
				element.delete() ;
			}
		}
		finally {
			JoveNotes.db.returnConnection( conn ) ;
		}
		
		return element ;
	}
	
	public int size() throws Exception {
		
		final String sql = "SELECT count(*) from `jove_notes`.`persistent_queue`" ;
		
		int size = 0 ;
		Connection conn = JoveNotes.db.getConnection() ;
		try {
			logQuery( "PersistentQueue::size", sql ) ;
			PreparedStatement psmt = conn.prepareStatement( sql ) ;
			ResultSet rs = psmt.executeQuery() ;
			rs.next() ;
			size = rs.getInt( 1 ) ;
		}
		finally {
			JoveNotes.db.returnConnection( conn ) ;
		}
		return size ;
	}
}
